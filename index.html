<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Kinect Challenge 2013 - Herramientas para el desarrollo</title>

		<meta name="description" content="Kinect Challenge 2013 - Herramientas para el desarrollo">
		<meta name="author" content="Moritz WUndke">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Title Slide -->
				<section>
					<h1>Kinect Challenge 2013</h1>
					<h3>Herramientas para el desarrollo</h3>
					<p>
						<small>Moritz Wundke - Lead Programmer <a href="http://www.tragnarion.com/" target="_blank">Tragnarion Studios</a></small>
						
					</p>
					<p>
						<small><a href="https://github.com/Tragnarion/kinectchallenge2013" target="_blank">Codigo fuente</a>
						<a href="http://tragnarion.github.com/kinectchallenge2013" target="_blank">Presentación</a></small>
					</p>
				</section>

				<!-- Introduction Slide -->
				<section>
					<section>
						<h2>Herramientas</h2>
						<p>
							Una herramienta de desarrollo es tan simple como un script que apaga un equipo a una determinada hora o tan complicado como un sistema de distribución automática ala Steam.
						</p>
						<aside class="notes">
							Ask the attendends if they use tools for their developments and in any case if they created there own already?
						</aside>
					</section>
					<section>
						<h3>¿Para quíen?</h3>
						<p class="fragment">
							Las herramientas son para todos. Si alguien dice que no necesita una herramienta o que ya tiene todas las necesarias simplemente aún no ha descubierto donde fallan.
						</p>
						<ul>
							<li class="fragment"><em>Diseño:</em> necesita herramientas para analizar el producto o averiguar porqué falla, ...</li>
							<li class="fragment"><em>Arte:</em> ha de conocer el estado de los recursos y si es viable usar más o menos, ...</li>
							<li class="fragment"><em>Sonido:</em> ha de saber si la espacialización es correcta en un nivel, ...</li>
							<li class="fragment"><em>Programación:</em> ha de poder verificar porqué se reinició el juego, ...</li>
						</ul>
						<p class="fragment">
							Las posibilidades son infinitas!
						</p>
						<aside class="notes">
							Some examples: PRG: script to make binaries, ART: Plugin de FBX para importar modelos en el UE3.
						</aside>
					</section>
					<section>
						<h3>¿Por qué?</h3>
						<p class="fragment">
							Cuando pensamos en crear una herramienta es importante no caer en la tentación de hacerlo todo de cero. ¿Existe ya una herramienta que encaje en mis requerimientos? ¿Es viable usarla? ¿El coste es menor que un desarrollo propio?
						</p>
						<p class="fragment">
							Si no encontramos ninguna herramienta que se ajuste a nuestras necesidades es probable que la tengamos que crear nosotros mismos.
						</p>
					</section>
					<section>
						<h3>¡Inversión!</h3>
						<p class="fragment">
							La mayoría de las veces es muy difícil demostrar la vitalidad de una herramienta. Es posible que la herramienta tenga un único uso y se use una sola vez pero que sea muy difícil realizar una tarea a mano.
						</p>
						<p class="fragment">
							Un ejemplo de una herramienta de un sólo uso fue la que desarrollamos para descubrir que en un nivel teníamos recursos cargados sin que nos dimos cuenta. Sólo se ejecutó una vez pero se consiguió resolver el problema que no parecía tener solución en un principio.
						</p>
					</section>
				</section>

				<!-- Software development tools -->
				<section>
					<section>
						<h2>Herramientas para el desarollo</h2>
						<p class="fragment">
							Ante cualquier desarrollo, por pequeño que sea, es importante darnos cuenta de que existe una serie de herramientas esenciales que nos hagan el día día más sencillo.
						</p>
						<p class="fragment">
							Gran parte de los proyectos, sobre todo de software, fracasan por una mala planificación y diseño. Es muy importante que uno se acostumbre a usar:
						</p>
						<ul>
							<li class="fragment"><em>Control de versiones</em></li>
							<li class="fragment"><em>Planificador de tareas</em></li>
							<li class="fragment"><em>Base de datos de bugs</em></li>
							<li class="fragment"><em>Integración continua</em></li>
						</ul>
					</section>

					<section>
						<h2>Control de versiones I</h2>
						<p class="fragment">
							La regla de oro del desarrollo de software es: <b>Lo que no esta versionado no existe</b>
						</p>
						<p class="fragment">
							Aunque parezca una frase populista tiene mucho sentido. Trabajando en equipo es importante que cada miembro sepa en lo que esta trabajando ya que entre ellos existen dependencias. Una persona que trabaja en local trabaja fuera del proyecto y representa un peligro:
						</p>
						<ul>
							<li class="fragment"><em>Perdida de trabajo:</em> un simple fallo de un disco duro nos puede hacer perder semanas de trabajo.</li>
							<li class="fragment"><em>Conflictos:</em> entre el trabajo de varias personas.</li>
							<li class="fragment"><em>Bugs:</em> sin un log de cambios es imposible saber porque empezó a fallar un determinado sistema.</li>
							<li class="fragment"><em>Culpable:</em> a veces es importante poder señalizar al culpable de un cambio.</li>
						</ul>
					</section>
					<section>
						<h2>Control de versiones II</h2>
						<p class="fragment">
							La mayoría de sistemas de control de versiones se pueden catalogar en dos grupos:
						</p>
						<ul>
							<li class="fragment"><em>Sistemas de control de versiones centralizado</em></li>
							<ul>
								<li class="fragment"><em>Subversion (SVN) o Perforce</em></li>
							</ul>
							<li class="fragment"><em>Distribuido o sistema de control decentralizado</em></li>
							<ul>
								<li class="fragment"><em>Git, Mercurial (hg) o Kiln</em></li>
							</ul>
						</ul>
						<aside class="notes">
							Talk a bit about what are they all about. Kiln is a fork of Mercurial.

							SVN: Most commonly used
							Perforce: Excelent support for big files
							Git: Text files
							Mercurial: Using the big file extension supports BLOBs too
							Kiln: comes with extra sugar like a code review system
						</aside>
					</section>
					<section>
						<h2>Planificador de tareas</h2>
						<p class="fragment">
							Si no sabemos lo que estamos haciendo seguramente no llegaremos a terminar lo que queremos. La mayoría de herramientas siguen filosofías tales como:
						</p>
						<ul>
							<li class="fragment"><em>Scrum</em></li>
							<li class="fragment"><em>Kanban</em></li>
							<li class="fragment"><em>Lean</em></li>
							<li class="fragment"><em>Extreme Programming</em></li>
						</ul>
						<ul>
							<li class="fragment"><em>Existen herramientas gratuitas como:</em></li>
							<ul>
								<li class="fragment"><em>Trello:</em> especial para desarrollos usando Kanban</li>
								<li class="fragment"><em>Trac:</em> con plugins para Scrum</li>
							</ul>
							<li class="fragment"><em>O de pago:</em></li>
							<ul>
								<li class="fragment"><em>Green Hopper:</em> para Kanban o Scrum</li>
								<li class="fragment"><em>Hansoft:</em> para Kanban, Scrum, Lean o Extreme Programming</li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>Base de datos de bugs</h2>
						<p class="fragment">
							Otra herramienta sumamente importante es la que nos ayuda a saber lo que falla. Llegado un punto en el desarrollo es esencial que sepamos que está roto o que partes han de mejorarse para poder llegar a la calidad deseada.
						</p>
						<ul>
							<li class="fragment"><em>Existen herramientas gratuitas como:</em></li>
							<ul>
								<li class="fragment"><em>Trac:</em> un ticket puede ser considerado una tarea o un bug.</li>
								<li class="fragment"><em>Bugzilla:</em> sistema tradicional para gestión de bugs</li>
							</ul>
							<li class="fragment"><em>O de pago:</em></li>
							<ul>
								<li class="fragment"><em>Jira:</em> para Kanban o Scrum</li>
								<li class="fragment"><em>FogBugz:</em> para Kanban, Scrum, Lean o Extreme Programming</li>
								<li class="fragment"><em>Hansoft:</em> incluye un sistema de control de calidad muy sofisticado</li>
							</ul>
						</ul>
						<aside class="notes">
							Talk about the typical example when a crash happens and someone has to findout what could have been produced the crash. Seek commits made and what has been fixed recently.
						</aside>
					</section>
					<section>
						<h2>Integración continua (CI) I</h2>
						<p class="fragment">
							La integración continua se basa en hacer integraciones automáticas de un proyecto cada vez que se produce un cambio en el proyecto.
						</p>
						<p class="fragment">
							Cada vez que subimos codigo al repositorio se disparan acciones que compilan el cambio, realizan cambios y envian informes de resultados.
						</p>
						<p class="fragment">
							Un ejemplo son las <b>nighlty-builds</b>. Cada noche se realiza un proceso completo hasta empaquetar la applicación con el fin de realizar pruebas exhaustivas con la mayor frequencia posible.
						</p>
					</section>
					<section>
						<h2>Integración continua (CI) II</h2>
						<p class="fragment">
							Hay que tener claro que no todos los procesos se pueden crear en un CI, si aumenta la complejidad de la tarea es una buena idea crear una herramienta que nos haga de interfaz.
						</p>
						<p class="fragment">
							Existen muchas herramientas gratuitas, algunos ejemplos podrían ser:
						</p>
						<ul>
							<li class="fragment"><em>Hudson</em></li>
							<li class="fragment"><em>Buildbot</em></li>
							<li class="fragment"><em>Jenkins</em></li>
						</ul>
						<aside class="notes">
							Talk about why nightlies are uberimportant! If we now the changeset of each build finding which changes produced a bug is vital. If we find early what is the cause and have it isolated we can seek for a proper fix.
						</aside>
					</section>
					<section>
						<h2>GitHub y BitBucket</h2>
						<p class="fragment">
							Ambos son servicios que proporcionan repositorios públicos y privados. Incluyen muchas herramientas en su interfaz web.
						</p>
						<p class="fragment">
							GitHub.com
						</p>
						<ul>
							<li class="fragment"><em>Repositorios públicos ilimitados</em></li>
							<li class="fragment"><em>Repositorios privados de pago</em></li>
							<li class="fragment"><em>Comunidad open-source inmejorable</em></li>
							<li class="fragment"><em>Soporta GIT aunque existe un plugin para Mercurial</em></li>
						</ul>
						<p class="fragment">
							BitBucket.org
						</p>
						<ul>
							<li class="fragment"><em>Repositorios públicos ilimitados</em></li>
							<li class="fragment"><em>Repositorios privados ilimitados para hasta 5 usuarios</em></li>
							<li class="fragment"><em>Siporta Git y Mercurial</em></li>
						</ul>
						<aside class="notes">
							Why online repos are a good choice for small teams!
						</aside>
					</section>
				</section>

				<!-- Building your own tools -->
				<section>
					<section>
						<h2>Herramientas propias</h2>
						<p class="fragment">
							Como empezar una herramienta y qué hemos de tener en cuenta!
						</p>
						<ul>
							<li class="fragment"><em>Directas e indirectas</em></li>
							<li class="fragment"><em>Los datos</em></li>
							<li class="fragment"><em>Interfaz por commandos</em></li>
							<li class="fragment"><em>Observar al usuario!</em></li>
						</ul>
					</section>
					<section>
						<h2>Directas e indirectas</h2>
						<p class="fragment">
							En general suelen existir dos tipos de herramientas: directas, aquellas que afectan directamente al desarrollo del producto, e indirectas, aquellas que no están directamente ligadas al desarrollo del producto.
						</p>
						<p class="fragment">
							Las herramientas directas son las más evidentes. Un juego, por ejemplo, requiere de un editor de niveles. En cambio las herramientas indirectas son las que no se ven a simple vista y suelen caer en el olvido.
						</p>
						<aside class="notes">
							Ask attendees of they already created a indirect tool
						</aside>
					</section>
					<section>
						<h2>Los datos</h2>
						<p class="fragment">
							Los datos que una herramienta trata son vitales. Son datos binarios o no? Los datos nos indican como poder comunicarnos con otras herramientas.
						</p>
						<ul>
							<li class="fragment"><em>Bianrios:</em> fáciles de leer/escribir por un programa. Difícil para un humano.</li>
							<li class="fragment"><em>JSON, XML:</em> más lentos de leer/escribir pero legible por humanos. Pueden ser usados de meta-datos incrustados en los archivos binarios.</li>
							<li class="fragment"><em>CSV:</em> formato simple pero útil para representar datos sin procesar. Pueden ser importado en hojas de cálculo.</li>
						</ul>
						<aside class="notes">
							Make sure talk about that serializing data into test as JSON makes integration between different tools easy!
						</aside>
					</section>
					<section>
						<h2>Interfaz por commandos</h2>
						<p class="fragment">
							Al crear cualquier herramienta tenemos que tener en mente que pueda ser usado en infinidad de ámbitos. Si creamos las herramientas pensando desde el principio de que puedan ser usados por linea de comandos podremos integrarlas en otros sistemas. Incluso pueden ser usados por otras herramientas.
						</p>
						<p class="fragment">
							Una herramienta que no tenga una interfaz por commandos pierde la mitatd de su potencial al no poder integrarse en otras de manera directa.
						</p>
						<aside class="notes">
							Talk about the example of building Scourge. Many different tools working together. The whole system can be started using CI.
						</aside>
					</section>
					<section>
						<h2>Observar al usuario!</h2>
						<p class="fragment">
							La mayoría de las herramientas nacen de la necesidad de un individuo. En muchas ocasiones el individuo pide una determinada funcionalidad que en realidad no se ajusta a sus necesidades. Es importante realizar un análisis de conocimiento para poder descubir qué realmente requiere la persona que nos pide una herramienta.
						</p>
						<p class="fragment">
							Para poder realizar un análisis nos centraremos en tres tipos de conocimiento:
						</p>
						<ul>
							<li class="fragment"><em>Explícito:</em> conocimiento del que somos totalmente cocientes. Representa una fracción del conocimiento.</li>
							<li class="fragment"><em>Implícito:</em> conocimiento del que somos cocientes pero que hemos adquirido como los hábitos.</li>
							<li class="fragment"><em>Tácito:</em> totalmente inconsciente. Muy difícil de registrar.</li>
						</ul>
						<aside class="notes">
							Like in every development creating tools has to birden with users too. The user hardly knows what he needs and will for sure ask for more stuff that is really required.
						</aside>
					</section>
				</section>

				<!-- Building your own tools -->
				<section>
					<section>
						<h2>Caso prácticos</h2>
						<p>
							Vamos a ver una serie de ejemplos de herramientas reales y otras creadas expresamente para esta charla.
						</p>
						<ul>
							<li class="fragment"><em>Scripts por lotes</em></li>
							<li class="fragment"><em>Python</em></li>
							<li class="fragment"><em>Telemetría</em></li>
							<li class="fragment"><em>Editor de niveles</em></li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Scripts por lotes I</h2>
						<p>
							Crear scripts en archivos por lotes tipo .bat son  de mucha utilidad. A veces se olvida la facilidad que ofrecen por su poca complejidad.
						</p>
						<p>
							Un script por lotes es ideal para mezclar diversas tareas o funcionalidad de otras herramientas y ofrece todo ese poder para usuarios no técnicos.
						</p>
					</section>
					<section>
						<h2>Scripts por lotes II</h2>
						<p>
							Un ejemplo real te archivos por lotes es el sistema de empaquetado de <a href="http://www.scourgeoutbreak.com/" target="_blank">Scourge: Outbreak</a>. El juego es compatible con hasta 4 plataformas: PC, OSx, Xbox 360 y PS3.
						</p>
						<p>
							El problema viene cuando cada plataforma conlleva distintas limitaciones los cuales el equipo entero ha de respetar. Lo cual nos define los siguientes requisitos para el sistema de empaquetado:
						</p>
						<ul>
							<li class="fragment"><em>Sencillo:</em> Crear un instalador de una plataforma con un sólo click de ratón.</li>
							<li class="fragment"><em>Flexible:</em> Crear un instalador solamente de lo que se esté desarrollando.</li>
							<li class="fragment"><em>Estable:</em> La creación debe completar sin errores y si existen errores han de presentarse de manera entendible.</li>
						</ul>
						<aside class="notes">
							Example: Texture capacities on mobile devices vs consoles vs PCs. We have to process the resources and so we shall create tools that takes that task.
						</aside>
					</section>
					<section>
						<h2>Scripts por lotes III</h2>
						<p>
							Para poder ejecutar distintas acciones dependiendo de la plataforma deseada podemos usar saltos condicionales.
						</p>
						<pre><code>@echo off
set Platform=PC
rem set Platform=MAC
rem set Platform=XBOX

goto:section_%Platform%

:section_PC
echo This is the PC Section
goto:end

:section_MAC
echo This is the MAC Section
goto:end

:section_XBOX
echo This is the XBOX Section
goto:end

:end
pause</code></pre>
					<p>
						Si usamos un argumento de linea de comandos como identificador de plataforma podremos ejecutar una serie de acciones distintas para cada una de ellas.
					</p>
					</section>
					<section>
						<h2>Scripts por lotes IV</h2>
						<p>
							Otro truco útil cuando usamos scripts por lotes es la habilidad de definir funciones recusables.
						</p>
						<pre><code>@echo off
goto:end_functions

:myFunction
echo This is just a simple function
goto:eof

:end_functions</code></pre>
					</section>
					<section>
						<h2>Scripts por lotes V</h2>
						<p>
							Una tarea común cuando procesamos datos por lotes es iterar sobre una lista. El siguiente ejemplo itera sobre todas las palabras separadas por espacios de un archivo de texto y ejecuta una función para cada una de ellas.
						</p>
						<pre><code>:processWord
REM Word list from file
set WordList=
FOR /F "eol= tokens=* delims= usebackq" %%i IN (%1) DO (
	set WordList=%%i
)
FOR %%i IN (%WordList%) DO (
	%2 %%i
)
GOTO:EOF</code></pre>
					</section>
					<section>
						<h2>Scripts por lotes VI</h2>
						<p>
							Algunas acciones como averiguar si una cadena de texto contiene otra cadena de texto pueden volverse sumamente complicados y hay que sopesar si es necesario crear la tarea usando scripts por lotes.
						</p>
						<pre><code>:containsString
setlocal
set $answer=N
if {%1} EQU {} goto endContainsString
if {%1} EQU {""} goto endContainsString
if {%2} EQU {} goto endContainsString
if {%2} EQU {""} goto endContainsString
set $string=####%1####
set $string=%$string:####"=%
set $string=%$string:"####=%
if "%$string%" EQU "" goto endContainsString
set $string=%$string:####=%
set $substring=####%2####
set $substring=%$substring:####"=%
set $substring=%$substring:"####=%
if "%$substring%" EQU "" goto endContainsString
set $substring=%$substring:####=%
for /f "Tokens=*" %%k in ('@echo %%$string:%$substring%^=%%') do @set $work$=%%k
if NOT "%$string%" EQU "%$work$%" set $answer=Y
:endContainsString
endlocal&set $answer=%$answer%
GOTO:EOF</code></pre>
					</section>
					<section>
						<h2>Scripts por lotes VII</h2>
						<p>
							Otra tarea muy común es crear archivos comprimidos de carpetas enteras. Por ejemplo cuando hemos hecho un empaquetado de nuestra applicación nos podría interesar comprimirlo todo en un único archivo para facilitar la distribución de la misma.
						</p>
						<pre><code>Set objShell = CreateObject("Shell.Application" ) 
Set Ag=Wscript.Arguments 
set WshShell = WScript.CreateObject("WScript.Shell" ) 

Wscript.Echo "Compressing..."

' Create a new zip file
Set objFSO = CreateObject( "Scripting.FileSystemObject" )
Set objTxt = objFSO.OpenTextFile( Ag(1), 2, True )
objTxt.Write "PK" & Chr(5) & Chr(6) & String( 18, Chr(0) )
objTxt.Close
Set objTxt = Nothing

' Now just put the folder in...
Set DestFldr=objShell.NameSpace(Ag(1)) 
Set SrcFldr=objShell.NameSpace(Ag(0)) 
Set FldrItems=SrcFldr.Items 
DestFldr.CopyHere FldrItems, 16+256

' Sleep a bit, if not the explorer will kill the process :D
Do Until DestFldr.Items.Count = SrcFldr.Items.Count
    WScript.Sleep 200
Loop

Wscript.Echo "Compression done!"</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Python I</h2>
						<p class="fragment">
							Python es un lenguaje de programación dinámico interpretado muy usado en el desarrollo de videojuegos. Se usa especialmente para crear herramientas.
						</p>
						<p class="fragment">
							Las ventajas de Python para el desarrollo de herramientas son:
						</p>
						<ul>
							<li class="fragment"><em>Orientado a objetos</em></li>
							<li class="fragment"><em>Imperativo:</em> Programación en términos de estados y sus cambios</li>
							<li class="fragment"><em>Funcional:</em> Lambdas o yields</li>
							<li class="fragment"><em>Distribución de paquetes:</em> El índice de paquetes (PyPi)</li>
							<li class="fragment"><em>Cross-Platform</em></li>
						</ul>
					</section>
					<section>
						<h2>Python II</h2>
						<p class="fragment">
							Pero ¿por qué es tan usado en videojuegos?
						</p>
						<p class="fragment">
							Básicamente porque es multi-plataforma y favorece al desarrollo rápido debido a que si se necesita algo seguramente habrá un paquete de Python que ya lo haga. Y sino se crea. En Python tenemos al alcanza de un click:
						</p>
						<ul>
							<li class="fragment"><em>Qt:</em> mediante PySide (oficial) o PyQt</li>
							<li class="fragment"><em>Web:</em> mediante paquetes tales Web.Py (Aron Schwartz, Reddit), Twisted Matrix e otros</li>
							<li class="fragment"><em>Client Requests:</em> Requests, ...</li>
							<li class="fragment"><em>Y mucho más:</em> <a href="http://pypi.python.org/pypi?%3Aaction=browse">PyPi</a><img src="img/pypi.png"></li>
						</ul>
					</section>
					<section>
						<h2>Python III</h2>
						<p class="fragment">
							Nos encontramos en el caso de tener que comparar dos rutas y buscar si en ambas hay archivos duplicados.
						</p>
						<p class="fragment">
							Decidimos de crear una herramienta por el simple hecho de que se podría automatizar el proceso de verificar que ambas rutas no contuviesen elementos duplicados y resultaba más sencillo que usar un programa de comparación.
						</p>
					</section>
					<section>
						<h2>Python IV</h2>
						<pre><code>def walk_dir(dir):
    for f in os.listdir(dir):
        fullpath = os.path.join(dir,f)
        if os.path.isdir(fullpath) and not os.path.islink(fullpath):
            for x in walk_dir(fullpath):
                yield x
        else:
            yield fullpath

def compare_dirs(dir1, dir2):
    for file1 in walk_dir(dir1):
        file1_base = os.path.basename(file1).lower()
        for file2 in walk_dir(dir2):
            file2_base = os.path.basename(file2).lower()
            if file1_base == file2_base:
                print("Duplicated file found: %s\n - %s\n - %s"%(file1_base, file1, file2))</code></pre>
                		<p class="fragment">
							Hay alguna cosa que os llame la atención de manera especial?
						</p>
					</section>
					<section>
						<h2>Python IV</h2>
						<pre><code>for x in walk_dir(fullpath):
	yield x</code></pre>
					<p class="fragment">
							Lo primero que vemos es que en vez de usar la palabra clave <b>return</b> usamos <b>yield</b>. La idea es que cuando llegamos a un yield devolvemos el valor pero la ejecución no termina, sino que la siguiente vez que ejecutemos la función seguimos desde el mismo sitio. Lo que hemos hecho es usar un <b>generador</b> y que se suele usar cuando se tiene una gran cantidad de datos potenciales que se van a leer una sola vez.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Telemetria - Heat Maps I</h2>
						<p class="fragment">
							Las herramientas tele-métricas son herramientas indirectas que se suelen olvidar.
						</p>
						<p class="fragment">
							Un heatmap es una imagen sobrepuesta encima de otra que representa un entorno. La imagen sobrepuesta contiene marcas de <b>calor</b> para poder visualizar distintos hechos.
						</p>
						<p class="fragment">
							La siguiente imagen representa un mapa de muertes del juego <i>Transformers: War for Cybertron</i>. En ella podemos observar en que puntos del mapa se han producido muertes.
						<p>
						</p>
							<img src="img/DeathHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Heat Maps II</h2>
						<p>
							Otro ejemplo del mismo juego es el mapa de 'kills'.
						</p>
						<p>
							 Si observamos atentamente veremos que casi no hay diferencias pero esas diferencias son de vital importancia para el diseñador de niveles ya que nos puede mostrar que el usuario no esta jugando como esperábamos.
						<p>
						</p>
							<img src="img/KillHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Heat Maps III</h2>
						<p>
							Combinando ambos mapas podemos crear un mapa balanceado (normalizado en nuestro caso).
						<p>
						</p>
							<img src="img/NormalizedBalanceHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetría - Datos geográficos</h2>
						<p>
							No solo podemos capturar e analizar datos planos. Un ejemplo de datos geográficos es el sistema de telemetria para <b>Assassin's Creed</b> donde se analizan los movimientos e elecciones de los jugadores para representarlos después en el mundo 3D. 
						</p>
						<p>
							<img src="img/parachuting-1024x800.png">
						</p>
					</section>
					<section>
						<h2> Telemetría - Ejemplo práctico</h2>
						<p class="fragment">
							Un sistema simple de captura de datos consiste por lo general en:
						</p>
						<ul>
							<li class="fragment"><em>Servidor:</em> el servidor recibe los eventos de captura y los proceso.</li>
							<ul>
								<li class="fragment">Creado usando Web.Py</li>
							</ul>
							<li class="fragment"><em>Base de datos:</em> contiene todos los datos que se hayan enviado.</li>
							<ul>
								<li class="fragment">SQLite3 para desarrollos internos o PostgreSQL o MongoDB (NoSQL) si se quiere usar en producción.</li>
							</ul>
							<li class="fragment"><em>API:</em> API de acceso para poder comunicarse con el servidor.</li>
							<ul>
								<li class="fragment">JSON-RPC por su facilidad de implementación.</li>
							</ul>
						</ul>
					</section>

					<section>
						<h2>Telemetría - API - addGameplayEvent</h2>
						<p>
							Añadir un evento simple al sistema de telemetría:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "addGameplayEvent", 
    "params": {
        "type": 1, 
        "tag": "playername", 
        "loc": "location", 
        "data": {
            "timestamp": 12569537329,
            "content": "[The content goes here...]"
        }
    },
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [True|False], "id": 1}</code></pre>
					</section>

					<section>
						<h2> Telemetría - API - addBatchedGameplayEvent</h2>
						<p>
							Añadir un conjunto de eventos al sistema de telemetría:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "addBatchedGameplayEvent", 
    "params": {
        "type": 1, 
        "tag": "playername",
        "loc": "location", 
        "data": 
        [
            {
                "timestamp": 12569537329,
                "content": "[The content goes here...]"
            }
        ]
    }, 
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [True|False], "id": 1}</code></pre>
					</section>

					<section>
						<h2> Telemetría - API - getGameplayEvent</h2>
						<p>
							Devuelve un conjunto de eventos registrados:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "getGameplayEvent", 
    "params": 
    {
        "type": 1, 
        "tag": "playername"
    },
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [{}], "id": 1}</code></pre>
					</section>

				</section>

				<section>
					<section>
						<h1>Editor de niveles I</h1>
						<p>
							Creación de un editor de nivel sencillo pero versátil. Para este ejemplo tomaremos el juego <b>Platformer</b> de la biblioteca de XNA
						</p>
						<p>
							<img src="img/editor.png">
						</p>
					</section>
					<section>
						<h1>Editor de niveles II</h1>
						<p>
							Para poder empezar a crear el editor hemos de saber que funcionalidades debamos añadir:
						</p>
						<ul>
							<li class="fragment"><em>Crear mapas:</em> el editor ha de ser capaz de leer y escribir mapas que el juego pueda entender.</li>
							<li class="fragment"><em>Usar todos los recursos del juego:</em> tenemos que usar los mismos recursos que usaremos en el juego.</li>
							<li class="fragment"><em>Visualizar Telemetría:</em> El editor ha de ser capaz de visualizar datos telemétricos</li>
						</ul>
						<p class="fragment">
							El esqueleto del <a href="https://github.com/Tragnarion/kinectchallenge2013/tree/master/ToolsInGames/MapEditor" target="_blank">editor</a> es accesible para que podáis usarlo.
						</p>
					</section>
				</section>

				<section>
					<h1>Preguntas</h1>
				</section>

				<section>
					<h1>Grácias por esuchar</h1>
					<h3>Moritz Wundke</h3>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
