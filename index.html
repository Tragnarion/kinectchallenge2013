<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Kinect Challenge 2013 - Herramientas para el desarollo</title>

		<meta name="description" content="Kinect Challenge 2013 - Herramientas para el desarollo">
		<meta name="author" content="Moritz WUndke">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Title Slide -->
				<section>
					<h1>Kinect Challenge 2013</h1>
					<h3>Herramientas para el desarollo</h3>
					<p>
						<small>Moritz Wundke - Lead Programmer <a href="http://www.tragnarion.com/" target="_blank">Tragnarion Studios</a></small>
						
					</p>
					<p>
						<small><a href="https://github.com/Tragnarion/kinectchallenge2013" target="_blank">Codigo fuente</a>
						<a href="http://tragnarion.github.com/kinectchallenge2013" target="_blank">Presentación</a></small>
					</p>
				</section>

				<!-- Introduction Slide -->
				<section>
					<section>
						<h2>Herramientas</h2>
						<p>
							Una herramienta de desarollo es tan simple como un script que apaga un equipo a una determinada hora o tan complicado como un sistema de distribución automática ala Steam.
						</p>
					</section>
					<section>
						<h3>¿Para quíen?</h3>
						<p class="fragment">
							Las herramientas son para todos. Si alguien dice que no necesita una herramienta o que ya tiene todas las necesarias simplemente aún no ha descubierto donde fallan.
						</p>
						<ul>
							<li class="fragment"><em>Diseño</em> necesita herramientas para analizar el producto o averiguar porqué falla, ...</li>
							<li class="fragment"><em>Arte</em> ha de conocer el estado de los recursos y si es viable usar más o menos, ...</li>
							<li class="fragment"><em>Sonido</em> ha de saber si la espacialización es correcta en un nivel, ...</li>
							<li class="fragment"><em>Programación</em> ha de poder verificar porqué se reinició el juego, ...</li>
						</ul>
						<p class="fragment">
							Las posibilidades son infinitas!
						</p>
					</section>
					<section>
						<h3>¿Porqué?</h3>
						<p class="fragment">
							Cuando pensamos en crear una herramienta es importante no caer en la tentación de hacerlo todo de 0. ¿Existe ya una herramienta que encaje en mis requerimientos? ¿Es viable usarla? ¿El coste es menor que un desarrollo propio?
						</p>
						<p class="fragment">
							Si no encontramos ninguna herramienta que se ajuste a nuestras necesidades es probable que la tengamos que crear nosotros mismos.
						</p>
					</section>
					<section>
						<h3>¡Inversión!</h3>
						<p class="fragment">
							La mayoría de las veces es muy difícil demostrar la vitalidad de una herramienta. Es posible que la herramienta tenga un único uso y se use una sóla vez pero que sea muy difícil realizar una tarea a mano.
						</p>
						<p class="fragment">
							Un ejemplo de una herramienta de un sólo uso fue la que desarrollamos para descubir que en un nivel teniamos recursos cargados sin que nos dimos cuenta. Sólo se ejecutó una vez pero se consigió resolver el problema que no parecia tener solución en un principio.
						</p>
					</section>
				</section>

				<!-- Software development tools -->
				<section>
					<section>
						<h2>Herramientas para el desarollo</h2>
						<p class="fragment">
							Ante cualquier desarrollo, por pequeño que sea, es importante darnos cuenta de que existe una serie de herramientas esenciales que nos hagan el día día más sencillo.
						</p>
						<p class="fragment">
							Gran parte de los proyectos, sobre todo de software, fracasan por una mala planificación y diseño. Es muy importante que uno se acostumbre a usar:
						</p>
						<ul>
							<li class="fragment"><em>Control de versiones</em></li>
							<li class="fragment"><em>Planificador de tareas</em></li>
							<li class="fragment"><em>Base de datos de bugs/incidencias</em></li>
							<li class="fragment"><em>Integración continua</em></li>
						</ul>
					</section>

					<section>
						<h2>Control de versiones I</h2>
						<p class="fragment">
							La regla de oro del desarrollo de software es: <b>Lo que no esta versionado no existe</b>
						</p>
						<p class="fragment">
							Aunque parezca una frase populista tiene mucho sentido. Trabajándo en equipo es importante que cada miembro sepa en lo que esta trabajando ya que entre ellos existen dependencias. Una persona que trabaja en local trabaja fuera del proyecto y representa un peligro:
						</p>
						<ul>
							<li class="fragment"><em>Perdidia de trabajo:</em> un simple fallo de un disco duro nos puede hacer perder semanas de trabajo.</li>
							<li class="fragment"><em>Conflictos:</em> entre el trabajo de varias personas.</li>
							<li class="fragment"><em>Bugs:</em> sin un log de cambios es imposible saber porque empezó a fallar un determinado sistema.</li>
							<li class="fragment"><em>Culpable:</em> a veces es importante poder señalizar al culpable de un cambio.</li>
						</ul>
					</section>
					<section>
						<h2>Control de versiones II</h2>
						<p class="fragment">
							La mayoria de sistemas de control de versiones se pueden catalogar en dos grupos
						</p>
						<ul>
							<li class="fragment"><em>Sistemas de control de versiones centralizado</em></li>
							<ul>
								<li class="fragment"><em>Subversion (SVN) o Perforce</em></li>
							</ul>
							<li class="fragment"><em>Distribuido o sistema de control decentralizado</em></li>
							<ul>
								<li class="fragment"><em>Git, Mercurial (hg) o Kiln</em></li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>Planificador de tareas</h2>
						<p class="fragment">
							Si no sabemos lo que estamos haciendo seguramente no llegaremos a terminar lo que queremos. La mayoría de herramientas siguen filosofias tales como:
						</p>
						<ul>
							<li class="fragment"><em>Scrum</em></li>
							<li class="fragment"><em>Kanban</em></li>
							<li class="fragment"><em>Lean</em></li>
							<li class="fragment"><em>Extreme Programming</em></li>
						</ul>
						<ul>
							<li class="fragment"><em>Existen herramientas gratuitas como:</em></li>
							<ul>
								<li class="fragment"><em>Trello:</em> especial para desarollos usando Kanban</li>
								<li class="fragment"><em>Trac:</em> con plugins para Scrum</li>
							</ul>
							<li class="fragment"><em>O de pago:</em></li>
							<ul>
								<li class="fragment"><em>Green Hopper:</em> para Kanban o Scrum</li>
								<li class="fragment"><em>Hansoft:</em> para Kanban, Scrum, Lean o Extreme Programming</li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>Base de datos de bugs/incidencias</h2>
						<p class="fragment">
							Otra herramienta sumamente importante es la que nos ayuda a saber lo que falla. Llegado un punto en el desarrollo es esencial que sepamos que está roto o que partes han de mejorarse para poder llegar a la calidad deseada.
							Hablar sobre FogBugz, Jira y Trac
						</p>
						<ul>
							<li class="fragment"><em>Existen herramientas gratuitas como:</em></li>
							<ul>
								<li class="fragment"><em>Trello:</em> especial para desarollos usando Kanban</li>
								<li class="fragment"><em>Trac:</em> con plugins para Scrum</li>
							</ul>
							<li class="fragment"><em>O de pago:</em></li>
							<ul>
								<li class="fragment"><em>Green Hopper:</em> para Kanban o Scrum</li>
								<li class="fragment"><em>Hansoft:</em> para Kanban, Scrum, Lean o Extreme Programming</li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>Integración continua</h2>
						<p>
							Hablar sobre Hudson, Buildbot y Jenkins
						</p>
					</section>
					<section>
						<h2>GitHub y BitBucket</h2>
						<p class="fragment">
							Ambos son servicios que proporcionan repositorios public y privados. Incluyen muchas herramientas en su interfaz web.
						</p>
						<p class="fragment">
							GitHub.com
						</p>
						<ul>
							<li class="fragment"><em>Repositorios public ilimitados</em></li>
							<li class="fragment"><em>Repositorios privados de pago</em></li>
							<li class="fragment"><em>Comunidad open-source inmejorable</em></li>
							<li class="fragment"><em>Sólo soporta GIT</em></li>
						</ul>
						<p class="fragment">
							BitBucket.org
						</p>
						<ul>
							<li class="fragment"><em>Repositorios public ilimitados</em></li>
							<li class="fragment"><em>Repositorios privados de pago</em></li>
							<li class="fragment"><em>Comunidad open-source inmejorable</em></li>
							<li class="fragment"><em>Sólo soporta GIT</em></li>
						</ul>
					</section>
				</section>

				<!-- Building your own tools -->
				<section>
					<section>
						<h2>Herramientas propias</h2>
						<p class="fragment">
							Como empezar una herramienta y qué hemos de tener encuenta!
						</p>
						<ul>
							<li class="fragment"><em>Directas e indirectas</em></li>
							<li class="fragment"><em>Los datos</em></li>
							<li class="fragment"><em>Interfaz por commandos</em></li>
							<li class="fragment"><em>Observar al usuario!</em></li>
						</ul>
					</section>
					<section>
						<h2>Directas e indirectas</h2>
						<p class="fragment">
							En general suelen existir dos tipos de herramientas: directas, aquellas que afectan directamente al desarrollo del producto, e indirectas, aquellas que no están directamente ligadas al desarrollo del producto.
						</p>
						<p class="fragment">
							Las herramientas directas son las más evidentes. Un juego, por ejemplo, requiere de un editor de niveles. En cambio las herramientas indirectas son las que no se ven a simple vsita y suelen caer en el olvido.
						</p>
					</section>
					<section>
						<h2>Los datos</h2>
						<p class="fragment">
							Los datos que una herramienta trata son vitales. Son datos binarios o no? Los datos nos indican como poder comunicarnos con otras herramientas.
						</p>
						<ul>
							<li class="fragment"><em>Bianrios:</em> fáciles de leer/escribir por un programa. Difícil para un humano.</li>
							<li class="fragment"><em>JSON, XML:</em> más lentos de leer/escribir pero leible por humanos. Pueden ser usados de metadatos incustrados en los archivos binarios.</li>
							<li class="fragment"><em>CSV:</em> formato simple pero útil para representar datos sin procesar. Pueden ser importado en hojas de cálculo.</li>
						</ul>
					</section>
					<section>
						<h2>Interfaz por commandos</h2>
						<p class="fragment">
							Al crear cualquier herramienta tenemos que tener en mente que pueda ser usado en infinidad de ámbitos. Si creamos las herramientas pensando desde el principio de que puedan ser usados por linea de comandos podremos integrarlas en otros systemas. Incluso pueden ser usados por otras herramientas.
						</p>
					</section>
					<section>
						<h2>Observar al usuario!</h2>
						<p class="fragment">
							La mayoria de las herramientas nacen de la necesidad de un individuo. En muchas ocasiones el individuo pide una determinada funcionalidad que en realidad no se ajusta a sus necesidades. Es importante realizar un análisis de conocimiento para poder descubir qué realmente requiere la persona que nos pide una herramienta.
						</p>
						<p class="fragment">
							Para poder realizar un análisis nos centraremos en tres tipos de conocimiento:
						</p>
						<ul>
							<li class="fragment"><em>Explícito:</em> conocimiento del que somos totalmente concientes. Representa una fracción del conocimiento.</li>
							<li class="fragment"><em>Implícito:</em> conocimiento del que somos conciente pero que hemos adquirido como los hábitos.</li>
							<li class="fragment"><em>Tácito:</em> totalmente inconciente. Muy difícil de registrar.</li>
						</ul>
					</section>
				</section>

				<!-- Building your own tools -->
				<section>
					<section>
						<h2>Caso prácticos</h2>
						<p>
							Vamos a ver una serie de ejemplos de herramientas reales y otras creadas expresamente para esta charla.
						</p>
						<ul>
							<li class="fragment"><em>Scripts por lotes</em></li>
							<li class="fragment"><em>Python</em></li>
							<li class="fragment"><em>Telemetria</em></li>
							<li class="fragment"><em>Editor de niveles</em></li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Scripts por lotes I</h2>
						<p>
							Crear scripts en archivos por lotes tipo .bat es una herramiente de mucha utilidad. A veces se olvida la facilidad que orecen por su poca complejidad.
						</p>
						<p>
							Un script por lotes es ideal para mezclar diversas tareas o funcionalidad de otras herramientas y ofrece todo ese poder para usarios no técnicos.
						</p>
					</section>
					<section>
						<h2>Scripts por lotes II</h2>
						<p>
							Un ejemplo real te archivos por lotes es el sistema de empaquetado de <a href="http://www.scourgeoutbreak.com/" target="_blank">Scourge: Outbreak</a>. El juego es compatible con hasta 4 plataformas: PC, OSx, Xbox 360 y PS3.
						</p>
						<p>
							El problema viene cuando cada plataforma conlleva distintas limitaciones los cuales el equipo entero ha de respetar. Lo cual nos define los siguientes requisitos para el sistema de empaquetado:
						</p>
						<ul>
							<li class="fragment"><em>Sencillo:</em> Crear un instalador de una plataforma con un sólo click de ratón.</li>
							<li class="fragment"><em>Flexible:</em> Crear un instalador solamente de lo que se esté desarrollando.</li>
							<li class="fragment"><em>Estable:</em> La creación debe completar sin errores y si existen errores han de presentarse de manera entendible.</li>
						</ul>
					</section>
					<section>
						<h2>Scripts por lotes III</h2>
						<p>
							Para poder ejecutar distintas acciones dependiendo de la plataforma deseada podemos usar saltos condicionales.
						</p>
						<pre><code>@echo off
set Platform=PC
rem set Platform=MAC
rem set Platform=XBOX

goto:section_%Platform%

:section_PC
echo This is the PC Section
goto:end

:section_MAC
echo This is the MAC Section
goto:end

:section_XBOX
echo This is the XBOX Section
goto:end

:end
pause</code></pre>
					<p>
						Si usamos un argumento de linea de comandos como identificador de plataforma podremos ejecutar una serie de acciones distintas para cada una de ellas.
					</p>
					</section>
					<section>
						<h2>Scripts por lotes IV</h2>
						<p>
							Otro truco útil cuando usamos scripts por lotes es la habilidad de definir funciones reusables.
						</p>
						<pre><code>@echo off
goto:end_functions

:myFunction
echo This is just a simple function
goto:eof

:end_functions</code></pre>
					</section>
					<section>
						<h2>Scripts por lotesV</h2>
						<p>
							Una tarea común cuando procesamos datos por lotes es iterar sobre una lista. El siguiente ejemplo itera sobre todas las palabras separadas por espacios de un archivo de texto y ejecuta una función para cada una de ellas.
						</p>
						<pre><code>:processWord
REM Word list from file
set WordList=
FOR /F "eol= tokens=* delims= usebackq" %%i IN (%1) DO (
	set WordList=%%i
)
FOR %%i IN (%WordList%) DO (
	%2 %%i
)
GOTO:EOF</code></pre>
					</section>
					<section>
						<h2>Scripts por lotes VI</h2>
						<p>
							Algunas acciones como averiguar si una cadena de texto contiene otra cadena de texto pueden volverse sumamente complicados y hay que sopesar si es necesario crear la tarea usando scripts por lotes.
						</p>
						<pre><code>:containsString
setlocal
set $answer=N
if {%1} EQU {} goto endContainsString
if {%1} EQU {""} goto endContainsString
if {%2} EQU {} goto endContainsString
if {%2} EQU {""} goto endContainsString
set $string=####%1####
set $string=%$string:####"=%
set $string=%$string:"####=%
if "%$string%" EQU "" goto endContainsString
set $string=%$string:####=%
set $substring=####%2####
set $substring=%$substring:####"=%
set $substring=%$substring:"####=%
if "%$substring%" EQU "" goto endContainsString
set $substring=%$substring:####=%
for /f "Tokens=*" %%k in ('@echo %%$string:%$substring%^=%%') do @set $work$=%%k
if NOT "%$string%" EQU "%$work$%" set $answer=Y
:endContainsString
endlocal&set $answer=%$answer%
GOTO:EOF</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Python I</h2>
						<p class="fragment">
							Python es un lenguaje de programación dinámico interpretae muy usado en el desarrollo de videojuegos. Se usa especialmente para crear herramientas.
						</p>
						<p class="fragment">
							Las ventajas de python para el desarrollo de herramientas son:
						</p>
						<ul>
							<li class="fragment"><em>Orientado a objetos</em></li>
							<li class="fragment"><em>Imperativo:</em> Programación en términos de estados y sus cambios</li>
							<li class="fragment"><em>Funcional:</em> Lambdas o yields</li>
							<li class="fragment"><em>Distribución de paquetes:</em> El índice de paquetes (PyPi)</li>
							<li class="fragment"><em>Cross-Platform</em></li>
						</ul>
					</section>
					<section>
						<h2>Python II</h2>
						<p class="fragment">
							Pero ¿porqué es tan usado en videojuegos?
						</p>
						<p class="fragment">
							Básicamente porque es multiplataforma y favorece al desarrollo rápido debido a que si se necesita algo habrá un paquete de python qye lo haga. Y sino se crea. En Python tenemos al alcanze de un click:
						</p>
						<ul>
							<li class="fragment"><em>Qt:</em> mediante PySide (oficial) o PyQt</li>
							<li class="fragment"><em>Web:</em> mediante paquetes tales Web.Py (Aron Schwartz, Reddit), Twisted Matrix e otros</li>
							<li class="fragment"><em>Client Requests:</em> Requests, ...</li>
							<li class="fragment"><em>Y mucho más:</em> <a href="http://pypi.python.org/pypi?%3Aaction=browse">PyPi</a><img src="img/pypi.png"></li>
						</ul>
					</section>
					<section>
						<h2>Python III</h2>
						<p class="fragment">
							Vamos aver un ejemplo real. Nos encontramos en el caso de tener que comparar dos rutas y buscar si en ambas hay archivos duplicados.
						</p>
						<p class="fragment">
							Decidimos de crear una herramienta por el simple hecho de que se podría automatizar el proceso de verificar que ambas rutas no contuviesen elementos duplicados y resultaba más sencillo que usar un programa de comparación.
						</p>
					</section>
					<section>
						<h2>Python IV</h2>
						<pre><code>def walk_dir(dir):
    for f in os.listdir(dir):
        fullpath = os.path.join(dir,f)
        if os.path.isdir(fullpath) and not os.path.islink(fullpath):
            for x in walk_dir(fullpath):
                yield x
        else:
            yield fullpath

def compare_dirs(dir1, dir2):
    for file1 in walk_dir(dir1):
        file1_base = os.path.basename(file1).lower()
        for file2 in walk_dir(dir2):
            file2_base = os.path.basename(file2).lower()
            if file1_base == file2_base:
                print("Duplicated file found: %s\n - %s\n - %s"%(file1_base, file1, file2))</code></pre>
                		<p class="fragment">
							Vamos a explicar las partes importantes del código.
						</p>
					</section>
					<section>
						<h2>Python IV</h2>
						<p class="fragment">
							Lo primero que vemos es que en vez de usar la palabra clave <b>return</b> usamos <b>yield</b>. La idea es que cuando llegamos a un yield devolvemos el valor pero la ejecución no termina, sino que la siguiente vez que ejecutemos la función seguimos desde el mismo sitio. Lo que hemos hecho es usar un <b>generador</b> y que se suele usar cuando se tiene una gran cantidad de datos potenciales que se van a leer una sola vez.
						</p>
						<pre><code>for x in walk_dir(fullpath):
	yield x</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Telemetria - Heat Maps I</h2>
						<p class="fragment">
							Las herramientas telemétricas son herramientas indirectas que se suelen olvidar.
						</p>
						<p class="fragment">
							Un heatmap es una imagen sobrepuesta encima de otra que representa un entorno. La imagen sobrepuesta contiene marcas de <b>calor</b> para poder visualizar distintos hechos.
						</p>
						<p class="fragment">
							La siguiente imagen representa un mapa de muertes del juego <i>Transformers: War for Cybertron</i>. En ella podemos observar en que puntos del mapa se han producido muertes.
							<img src="img/DeathHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Heat Maps II</h2>
						<p>
							Otro ejemplo del mismo juego es el mapa de 'kills'.
						</p>
						<p>
							 Si observamos atentamente veremos que casi no hay diferencias pero esas diferencias son de vital importancia para el diseñador de niveles ya que nos puede mostrar que el usario no esta jugando como esperabamos.
							<img src="img/KillHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Heat Maps III</h2>
						<p>
							Combinando ambos mapas podemos crear un mapa balanceado (normalizado en nuestro caso). 
							<img src="img/NormalizedBalanceHeatmap.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Datos geográficos</h2>
						<p>
							No solo podemos capturar e analizar datos planos. Un ejemplo de datos geográficos es el sistema de telemetria para <b>Assassin's Creed</b> donde se analizan los movimientos e elecciones de los jugadores para representarlos después en el mundo 3D. 
						</p>
						<p>
							<img src="img/parachuting-1024x800.png">
						</p>
					</section>
					<section>
						<h2>Telemetria - Ejemplo práctico</h2>
						<p class="fragment">
							Un sistema simple de captura de datos consiste por lo general en:
						</p>
						<ul>
							<li class="fragment"><em>Servidor:</em> el servidor recibe los eventos de captura y los proceso.</li>
							<ul>
								<li class="fragment">Creado usando Web.Py</li>
							</ul>
							<li class="fragment"><em>Base de datos:</em> contiene todos los datos que se hayan enviado.</li>
							<ul>
								<li class="fragment">SQLite3 para desarrollos internos o PostgreSQL o MongoDB (NoSQL) si se quiere usar en producción.</li>
							</ul>
							<li class="fragment"><em>API:</em> API de acceso para poder comunicarse con el servidor.</li>
							<ul>
								<li class="fragment">JSON-RPC por su facilidad de implementación.</li>
							</ul>
						</ul>
					</section>

					<section>
						<h2>Telemetria - API - addGameplayEvent</h2>
						<p>
							Añadir un evento simple al sistema de telemetria:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "addGameplayEvent", 
    "params": {
        "type": 1, 
        "tag": "playername", 
        "loc": "location", 
        "data": {
            "timestamp": 12569537329,
            "content": "[The content goes here...]"
        }
    },
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [True|False], "id": 1}</code></pre>
					</section>

					<section>
						<h2>Telemetria - API - addBatchedGameplayEvent</h2>
						<p>
							Añadir un conjunto de eventos al sistema de telemetria:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "addBatchedGameplayEvent", 
    "params": {
        "type": 1, 
        "tag": "playername",
        "loc": "location", 
        "data": 
        [
            {
                "timestamp": 12569537329,
                "content": "[The content goes here...]"
            }
        ]
    }, 
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [True|False], "id": 1}</code></pre>
					</section>

					<section>
						<h2>Telemetria - API - getGameplayEvent</h2>
						<p>
							Devuelve un conjunto de eventos registrados:
						</p>
<pre><code>{
    "jsonrpc": "2.0", 
    "method": "getGameplayEvent", 
    "params": 
    {
        "type": 1, 
        "tag": "playername"
    },
    "id": 1
}</code></pre>
						<p>
							Respuesta:
						</p>
<pre><code>{"jsonrpc": "2.0", "result": [{}], "id": 1}</code></pre>
					</section>

				</section>

				<section>
					<section>
						<h1>Editor de niveles I</h1>
						<p>
							Creación de un editor de nivel sencillo pero versátil. Para este ejemplo tomaremos el juego <b>Platformer</b> de la biblioteca de XNA
						</p>
						<p>
							<img src="img/editor.png">
						</p>
					</section>
					<section>
						<h1>Editor de niveles II</h1>
						<p>
							Para poder empezar a crear el editor hemos de saber que funcionalidades debamos añadir:
						</p>
						<ul>
							<li class="fragment"><em>Crear mapas:</em> el editor ha de ser capaz de leer y escribir mapas que el juego pueda entender.</li>
							<li class="fragment"><em>Usar todos los recursos del juego:</em> tenemos que usar los mismos recursos que usaremos en el juego.</li>
							<li class="fragment"><em>Visualizar Telemetría:</em> El editor ha de ser capaz de visualizar datos telemétricos</li>
						</ul>
						<p class="fragment">
							El esqueleto del <a href="https://github.com/Tragnarion/kinectchallenge2013/tree/master/ToolsInGames/MapEditor" target="_blank">editor</a> es accesible para que podáis usarlo.
						</p>
					</section>
				</section>

				<section>
					<h1>Preguntas</h1>
				</section>

				<section>
					<h1>Grácias por esuchar</h1>
					<h3>Moritz Wundke</h3>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
